
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>【てらぞん】資産シミュレーター Pro</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Noto Sans JP', sans-serif;
    }
    /* Simple spinner for loading */
    #loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      flex-direction: column;
      gap: 1rem;
    }
    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border-left-color: #4f46e5;
      animation: spin 1s ease infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    @keyframes fade-in { 0% { opacity: 0; } 100% { opacity: 1; } }
    .animate-fade-in { animation: fade-in 0.3s ease-out forwards; }
    .animate-fade-in-fast { animation: fade-in 0.2s ease-out forwards; }
    .tutorial-highlight-box {
        position: fixed;
        border-radius: 8px;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
        z-index: 9998;
        transition: top 0.3s ease, left 0.3s ease, width 0.3s ease, height 0.3s ease, opacity 0.3s ease;
        pointer-events: none;
    }
    .tutorial-popover {
        position: fixed;
        z-index: 9999;
        transition: top 0.3s ease, left 0.3s ease, bottom 0.3s ease, opacity 0.3s ease;
    }
  </style>
  
  <!-- Step 1: Load Babel Standalone to transpile TSX in the browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Step 2: Define paths for modules -->
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom": "https://esm.sh/react-dom@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "recharts": "https://esm.sh/recharts@2.12.3?external=react,react-dom",
      "html2canvas": "https://esm.sh/html2canvas@1.4.1"
    }
  }
  </script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-slate-50 text-slate-800">
  <div id="root">
    <!-- Basic loading indicator, will be replaced by React -->
    <div id="loading">
      <div class="spinner"></div>
      <p>シミュレーターを読み込んでいます...</p>
    </div>
  </div>
  
  <!-- Step 3: Load and transpile the ENTIRE application script INLINE for stability -->
  <script type="text/babel" data-type="module">
    import React from 'react';
    import ReactDOM from 'react-dom/client';
    import { ResponsiveContainer, LineChart, CartesianGrid, XAxis, YAxis, Tooltip as RechartsTooltip, Legend, Line } from 'recharts';
    import html2canvas from 'html2canvas';

    // ====================================================================================
    //  All components and logic are now embedded here to avoid external file issues.
    // ====================================================================================

    const validateInputs = (inputs) => {
        const errors = {};
        const {
            simulationMode, currentAge, currentAssets, annualYield,
            monthlyInvestment, targetAssets, afterTaxMonthlyIncome,
            targetSavingsRate, targetGoalAge, goalSettingMode,
            fireMonthlyLivingCost, fireMonthlySideIncome, fireWithdrawalRate,
        } = inputs;

        const numCurrentAge = Number(currentAge);
        const numCurrentAssets = Number(currentAssets);
        const numTargetAssets = Number(targetAssets);

        // Common validations
        if (currentAge === '' || numCurrentAge <= 0 || !Number.isInteger(numCurrentAge)) {
            errors.currentAge = '1歳以上の整数で入力してください。';
        }
        if (currentAssets === '' || numCurrentAssets < 0) {
            errors.currentAssets = '0万円以上で入力してください。';
        }
        if (annualYield === '') {
            errors.annualYield = '数値を入力してください。';
        }

        // Mode-specific validations
        if (simulationMode === 'contribution' || simulationMode === 'savingsRate') {
            if (!targetAssets || numTargetAssets <= 0) {
                errors.targetAssets = '0より大きい値を入力してください。';
            } else if (numTargetAssets <= numCurrentAssets) {
                errors.targetAssets = '目標額は現在の資産より大きい値を入力してください。';
            }
        }
        
        if (simulationMode === 'contribution') {
            if (monthlyInvestment === '' || Number(monthlyInvestment) < 0) {
                errors.monthlyInvestment = '0円以上で入力してください。';
            }
        } else if (simulationMode === 'savingsRate') {
            if (afterTaxMonthlyIncome === '' || Number(afterTaxMonthlyIncome) < 0) {
                errors.afterTaxMonthlyIncome = '0円以上で入力してください。';
            }
            const numRate = Number(targetSavingsRate);
            if (targetSavingsRate === '' || numRate < 0 || numRate > 100) {
                errors.targetSavingsRate = '0～100%で入力してください。';
            }
        } else if (simulationMode === 'reverse') {
            if (afterTaxMonthlyIncome === '' || Number(afterTaxMonthlyIncome) < 0) {
                errors.afterTaxMonthlyIncome = '0円以上で入力してください。';
            }
            const numTargetGoalAge = Number(targetGoalAge);
            if (!targetGoalAge || numTargetGoalAge <= numCurrentAge) {
                errors.targetGoalAge = '目標年齢は現在より未来に設定してください。';
            }
            
            if (goalSettingMode === 'amount') {
                if (!targetAssets || numTargetAssets <= numCurrentAssets) {
                    errors.targetAssets = '目標額は現在の資産より大きい値を入力してください。';
                }
            } else { // fire
                if (fireMonthlyLivingCost === '' || Number(fireMonthlyLivingCost) < 0) {
                    errors.fireMonthlyLivingCost = '0円以上で入力してください。';
                }
                if (fireMonthlySideIncome === '' || Number(fireMonthlySideIncome) < 0) {
                    errors.fireMonthlySideIncome = '0円以上で入力してください。';
                }
                if (!fireWithdrawalRate || Number(fireWithdrawalRate) <= 0) {
                    errors.fireWithdrawalRate = '0より大きい値を入力してください。';
                }
            }
        }
        
        return errors;
    };
    
    // --- from components/Tutorial.tsx ---
    const TUTORIAL_STEPS = [
        { elementId: 'tutorial-step-1', title: '① モード選択', content: 'まずは、3つのシミュレーションモードから、あなたに合った計算方法を選んでみましょう！', position: 'bottom' },
        { elementId: 'tutorial-step-2', title: '② 基本情報の入力', content: 'ここに、あなたの現在の年齢や資産などを入力します。サンプルの値が入っていますが、自由に変更してくださいね。', position: 'bottom' },
        { elementId: 'tutorial-step-3', title: '③ シミュレーション結果', content: '入力を変えると、目標達成までの年数などの結果がリアルタイムでここに表示されます。', position: 'right' },
        { elementId: 'tutorial-step-4', title: '④ 資産推移グラフ', content: '将来の資産がどのように増えていくか、グラフで直感的に確認できます。', position: 'top' },
        { elementId: 'tutorial-step-5', title: '⑤ ライフイベント設定', content: '「将来、収入が上がる」「子供が生まれて積立額が変わる」など、未来の変化もシミュレーションに反映できます！', position: 'top' },
    ];
    const Tutorial = ({ isOpen, onClose }) => {
        const { useState, useEffect, useCallback, useRef } = React;
        const [currentStep, setCurrentStep] = useState(0);
        const [highlightStyle, setHighlightStyle] = useState({ opacity: 0 });
        const [popoverStyle, setPopoverStyle] = useState({ opacity: 0 });
        const [dontShowAgain, setDontShowAgain] = useState(false);
        const popoverRef = useRef(null);
        const originalScrollY = useRef(0);

        const positionTutorial = useCallback(() => {
            const step = TUTORIAL_STEPS[currentStep];
            const element = document.getElementById(step.elementId);

            if (element) {
                const scrollYToCenter = element.offsetTop + (element.offsetHeight / 2) - (window.innerHeight / 2);
                const docHeight = document.documentElement.scrollHeight;
                const winHeight = window.innerHeight;
                const clampedScrollY = Math.max(0, Math.min(scrollYToCenter, docHeight - winHeight));
                
                document.body.style.top = `-${clampedScrollY}px`;

                const rect = element.getBoundingClientRect();
                setHighlightStyle({
                    top: `${rect.top - 5}px`,
                    left: `${rect.left - 5}px`,
                    width: `${rect.width + 10}px`,
                    height: `${rect.height + 10}px`,
                    opacity: 1,
                });
                
                setTimeout(() => {
                    if (popoverRef.current) {
                        const popoverRect = popoverRef.current.getBoundingClientRect();
                        let newPopoverStyle = {};
                        if (window.innerWidth < 768) {
                            newPopoverStyle = { bottom: '20px', left: '20px', right: '20px', top: 'auto' };
                        } else {
                            const positions = {
                                top: { top: rect.top - popoverRect.height - 15, left: rect.left + rect.width / 2 - popoverRect.width / 2 },
                                bottom: { top: rect.bottom + 15, left: rect.left + rect.width / 2 - popoverRect.width / 2 },
                                left: { top: rect.top + rect.height / 2 - popoverRect.height / 2, left: rect.left - popoverRect.width - 15 },
                                right: { top: rect.top + rect.height / 2 - popoverRect.height / 2, left: rect.right + 15 },
                            };
                            const pos = positions[step.position] || positions.bottom;
                            pos.left = Math.max(10, Math.min(pos.left, window.innerWidth - popoverRect.width - 10));
                            pos.top = Math.max(10, Math.min(pos.top, window.innerHeight - popoverRect.height - 10));
                            newPopoverStyle = { top: `${pos.top}px`, left: `${pos.left}px` };
                        }
                        setPopoverStyle({ ...newPopoverStyle, opacity: 1 });
                    }
                }, 0);
            } else {
                setHighlightStyle({ opacity: 0 });
                setPopoverStyle({ ...popoverStyle, opacity: 0 });
            }
        }, [currentStep]);

        useEffect(() => {
            if (!isOpen) return;
            const body = document.body;
            originalScrollY.current = window.scrollY;
            const { position, top, width, overflow } = body.style;
            body.style.position = 'fixed';
            body.style.width = '100%';
            body.style.overflow = 'hidden';
            body.style.top = `-${originalScrollY.current}px`;
            return () => {
                body.style.position = position;
                body.style.top = top;
                body.style.width = width;
                body.style.overflow = overflow;
                window.scrollTo(0, originalScrollY.current);
            };
        }, [isOpen]);

        useEffect(() => {
            if (!isOpen) return;
            const timer = setTimeout(positionTutorial, 50);
            window.addEventListener('resize', positionTutorial);
            return () => {
                clearTimeout(timer);
                window.removeEventListener('resize', positionTutorial);
            };
        }, [isOpen, currentStep, positionTutorial]);


        const handleNext = () => setCurrentStep(prev => Math.min(prev + 1, TUTORIAL_STEPS.length - 1));
        const handlePrev = () => setCurrentStep(prev => Math.max(prev - 1, 0));
        const handleClose = () => onClose(dontShowAgain);

        if (!isOpen) return null;
        
        const step = TUTORIAL_STEPS[currentStep];

        return (
            <div aria-modal="true" role="dialog" className="fixed inset-0 z-50">
                <div className="tutorial-highlight-box" style={highlightStyle}></div>
                <div ref={popoverRef} className="tutorial-popover bg-white rounded-lg shadow-2xl p-5 w-[calc(100vw-40px)] max-w-sm" style={popoverStyle}>
                    <h3 className="text-lg font-bold text-indigo-600 mb-2">{step.title}</h3>
                    <p className="text-sm text-slate-600 mb-4">{step.content}</p>
                    <div className="flex justify-between items-center">
                        <div className="flex space-x-2">
                           {TUTORIAL_STEPS.map((_, index) => (
                             <span key={index} className={`block w-2 h-2 rounded-full ${currentStep === index ? 'bg-indigo-500' : 'bg-slate-300'}`}></span>
                           ))}
                        </div>
                        <div className="flex items-center space-x-2">
                            {currentStep > 0 && <button onClick={handlePrev} className="text-sm text-slate-500 hover:text-slate-800 transition">戻る</button>}
                            {currentStep < TUTORIAL_STEPS.length - 1 ? (
                                <button onClick={handleNext} className="text-sm bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-indigo-700 transition">次へ</button>
                            ) : (
                                <button onClick={handleClose} className="text-sm bg-emerald-500 text-white font-semibold py-2 px-4 rounded-md hover:bg-emerald-600 transition">完了！</button>
                            )}
                        </div>
                    </div>
                     <div className="mt-5 pt-4 border-t border-slate-200 flex justify-between items-center">
                        <label className="flex items-center text-xs text-slate-500 cursor-pointer">
                            <input type="checkbox" checked={dontShowAgain} onChange={(e) => setDontShowAgain(e.target.checked)} className="h-4 w-4 text-indigo-600 border-slate-300 rounded focus:ring-indigo-500" />
                            <span className="ml-2">今後は表示しない</span>
                        </label>
                        <button onClick={handleClose} className="text-xs text-slate-400 hover:text-slate-600 transition">ツアーを終了</button>
                    </div>
                </div>
            </div>
        );
    };

    // --- from components/InfoIcon.tsx ---
    const InfoIcon = ({ className }) => {
      return (
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          className={`h-4 w-4 inline-block ${className}`}
          fill="none" 
          viewBox="0 0 24 24" 
          stroke="currentColor" 
          strokeWidth={2}
        >
          <path strokeLinecap="round" strokeLinejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      );
    };

    // --- from components/Tooltip.tsx ---
    const Tooltip = ({ text, children, className }) => {
      return (
        <div className={`relative flex items-center group ${className || ''}`}>
          {children}
          <div className="absolute bottom-full mb-2 w-max max-w-xs p-2 text-sm text-white bg-slate-700 rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-10">
            {text}
          </div>
        </div>
      );
    };

    // --- from hooks/useSimulation.ts ---
    const useSimulation = (inputs) => {
        const { useMemo } = React;
        
        const MAX_YEARS = 100;

        const runForwardSimulation = (
            currentAge,
            currentAssets,
            monthlyInvestment,
            annualYield,
            targetAssets,
            lifeEvents,
            initialMonthlyIncome
        ) => {
            if (currentAge <= 0 || targetAssets <= 0 || currentAssets >= targetAssets) {
                return { results: null, chartData: [] };
            }

            const targetAmount = targetAssets * 10000;

            const sortedLifeEvents = [...lifeEvents]
                .filter(event => (Number(event.age) || 0) > 0)
                .sort((a, b) => (Number(a.age) || 0) - (Number(b.age) || 0));
            
            const lifeEventsMap = new Map();
            sortedLifeEvents.forEach(event => {
              const age = Number(event.age) || 0;
              if (age >= currentAge) {
                lifeEventsMap.set(age, event);
              }
            });
            
            const originalEventAges = new Set(sortedLifeEvents.map(e => Number(e.age)));

            const monthlyRate = annualYield >= 0
                ? Math.pow(1 + annualYield / 100, 1 / 12) - 1
                : annualYield / 100 / 12;
            
            let newAssets = currentAssets * 10000;
            let principal = currentAssets * 10000;
            
            let currentMonthlyInvestment = monthlyInvestment;
            let currentMonthlyIncome = initialMonthlyIncome;

            const data = [{
              age: currentAge,
              totalAssets: Math.round(newAssets / 10000),
              principal: Math.round(principal / 10000),
              isEvent: originalEventAges.has(currentAge),
            }];

            let months = 0;
            let lastAge = currentAge;

            while (newAssets < targetAmount) {
              months++;
              const currentAgeInYears = Math.floor(currentAge + (months - 1) / 12);
              if (currentAgeInYears > lastAge) {
                 data.push({
                    age: currentAgeInYears,
                    totalAssets: Math.round(newAssets / 10000),
                    principal: Math.round(principal / 10000),
                    isEvent: originalEventAges.has(currentAgeInYears),
                });
                lastAge = currentAgeInYears;
              }
              
              if (lifeEventsMap.has(currentAgeInYears)) {
                  const event = lifeEventsMap.get(currentAgeInYears);
                  if (event) {
                      // Correctly handle income update: update if a valid number (including 0) is provided.
                      if (event.newMonthlyIncome !== '' && !isNaN(Number(event.newMonthlyIncome))) {
                          currentMonthlyIncome = Number(event.newMonthlyIncome);
                      }

                      // Calculate new investment based on the potentially updated income
                      if (event.goalType === 'rate') {
                          const newRate = Number(event.goalValue) || 0;
                          currentMonthlyInvestment = (currentMonthlyIncome * newRate) / 100;
                      } else { // 'amount'
                          currentMonthlyInvestment = Number(event.goalValue) || 0;
                      }
                      lifeEventsMap.delete(currentAgeInYears);
                  }
              }

              const monthlyInvestAmount = currentMonthlyInvestment * 10000;
              const interest = newAssets * monthlyRate;
              newAssets += interest;
              if (monthlyInvestAmount > 0) {
                newAssets += monthlyInvestAmount;
                principal += monthlyInvestAmount;
              }
              if (months >= MAX_YEARS * 12) break;
            }
            
            const finalAge = currentAge + months / 12;
            data.push({
                age: Number(finalAge.toFixed(2)),
                totalAssets: Math.round(newAssets / 10000),
                principal: Math.round(principal / 10000),
                isEvent: originalEventAges.has(Math.floor(finalAge)),
            });

            if (newAssets < targetAmount) {
              return { results: { isAchievable: false }, chartData: data.slice(0, 1) };
            }

            const yearsToGoal = Math.floor(months / 12);
            const monthsToGoal = months % 12;
            const goalAgeExact = currentAge * 12 + months;
            const goalAge = Math.floor(goalAgeExact / 12);
            const goalAgeMonthsPart = goalAgeExact % 12;

            const results = {
              isAchievable: true, goalAge, goalAgeMonthsPart, yearsToGoal, monthsToGoal,
              finalTotalAssets: Math.round(newAssets / 10000),
              totalPrincipal: Math.round(principal / 10000),
              totalInterest: Math.round((newAssets - principal) / 10000),
              finalAge,
            };

            return { results, chartData: data };
        }

        const runSimulationForDuration = (
            currentAge, currentAssets, monthlyInvestment, annualYield, durationInYears,
            lifeEvents, initialMonthlyIncome
        ) => {
            const monthlyRate = annualYield >= 0
                ? Math.pow(1 + annualYield / 100, 1 / 12) - 1
                : annualYield / 100 / 12;
            let newAssets = currentAssets * 10000;
            let principal = currentAssets * 10000;
            const totalMonths = Math.max(0, Math.round(durationInYears * 12));
            const data = [{
                age: currentAge,
                totalAssets: Math.round(newAssets / 10000),
                principal: Math.round(principal / 10000),
            }];

            let months = 0;
            let lastAge = currentAge;
            while (months < totalMonths) {
                months++;
                const monthlyInvestAmount = monthlyInvestment * 10000;
                const interest = newAssets * monthlyRate;
                newAssets += interest;
                if (monthlyInvestAmount > 0) {
                    newAssets += monthlyInvestAmount;
                    principal += monthlyInvestAmount;
                }
                const currentAgeInYears = Math.floor(currentAge + (months - 1) / 12);
                if (currentAgeInYears > lastAge) {
                    data.push({
                        age: currentAgeInYears,
                        totalAssets: Math.round(newAssets / 10000),
                        principal: Math.round(principal / 10000),
                    });
                    lastAge = currentAgeInYears;
                }
            }
            data.push({
                age: Number((currentAge + durationInYears).toFixed(2)),
                totalAssets: Math.round(newAssets / 10000),
                principal: Math.round(principal / 10000),
            });
            const results = {
                finalTotalAssets: Math.round(newAssets / 10000),
                totalPrincipal: Math.round(principal / 10000),
                totalInterest: Math.round((newAssets - principal) / 10000),
            };
            return { results, chartData: data };
        };


      return useMemo(() => {
        if (!inputs) {
            return { results: null, chartData: [], reverseResults: null };
        }

        const currentAge = Number(inputs.currentAge) || 0;
        const currentAssets = Number(inputs.currentAssets) || 0;
        const annualYield = Math.round(Number(inputs.annualYield) || 0);
        const afterTaxMonthlyIncome = Number(inputs.afterTaxMonthlyIncome) || 0;
        
        let effectiveTargetAssets = 0;
        if (inputs.simulationMode === 'reverse' && inputs.goalSettingMode === 'fire') {
            const livingCost = Number(inputs.fireMonthlyLivingCost) || 0;
            const sideIncome = Number(inputs.fireMonthlySideIncome) || 0;
            const withdrawalRate = Number(inputs.fireWithdrawalRate) || 0;
            if (withdrawalRate > 0) {
                const requiredAnnualSpending = (livingCost - sideIncome) * 12;
                if (requiredAnnualSpending > 0) {
                    effectiveTargetAssets = requiredAnnualSpending / (withdrawalRate / 100);
                }
            }
        } else {
            effectiveTargetAssets = Number(inputs.targetAssets) || 0;
        }

        if (inputs.simulationMode === 'reverse') {
            const targetGoalAge = Number(inputs.targetGoalAge) || 0;
            
            if (effectiveTargetAssets <= currentAssets) {
                return {
                    results: null,
                    chartData: [],
                    reverseResults: {
                        isAchievable: true,
                        feedbackMessage: 'おめでとうございます！すでに目標資産額を達成しています。',
                        requiredMonthlyInvestment: 0,
                        requiredSavingsRate: 0,
                        handsOff: null,
                    },
                };
            }
            if (targetGoalAge <= currentAge) {
                return {
                    results: null,
                    chartData: [],
                    reverseResults: {
                        isAchievable: false,
                        feedbackMessage: '目標達成年齢は、現在の年齢より未来の年齢を設定してください。',
                        handsOff: null,
                    },
                };
            }

            // Plan A: Calculate "Hands-off Plan" (zero additional investment)
            const handsOffSim = runForwardSimulation(currentAge, currentAssets, 0, annualYield, effectiveTargetAssets, [], afterTaxMonthlyIncome);
            const handsOffResults = handsOffSim.results?.isAchievable ? handsOffSim.results : null;

            // Plan B: Calculate required investment for user's "Goal Achievement Plan"
            let requiredMonthlyInvestment = 0;
            let isAchievable = true;

            if (handsOffResults && handsOffResults.finalAge <= targetGoalAge) {
                requiredMonthlyInvestment = 0;
            } else {
                let low = 0, high = effectiveTargetAssets, foundInvestment = -1;
                for (let i = 0; i < 100; i++) {
                    const mid = low + (high - low) / 2;
                    if (mid < 0.01) { low = mid; continue; }
                    const sim = runForwardSimulation(currentAge, currentAssets, mid, annualYield, effectiveTargetAssets, [], afterTaxMonthlyIncome);
                    if (sim.results?.isAchievable && sim.results.finalAge <= targetGoalAge) {
                        foundInvestment = mid;
                        high = mid;
                    } else {
                        low = mid;
                    }
                    if (high - low < 0.01) break;
                }
                if (foundInvestment === -1) isAchievable = false;
                else requiredMonthlyInvestment = foundInvestment;
            }

            if (!isAchievable) {
                 return { results: null, chartData: [], reverseResults: { feedbackMessage: 'この目標は現実的ではありません。目標年齢を延ばすか、目標額・FIREプランを調整してください。', isAchievable: false, handsOff: handsOffResults } };
            }
            
            const durationYears = targetGoalAge - currentAge;
            const { results: finalState, chartData } = runSimulationForDuration(currentAge, currentAssets, requiredMonthlyInvestment, annualYield, durationYears, [], afterTaxMonthlyIncome);

            const requiredSavingsRate = afterTaxMonthlyIncome > 0 ? (requiredMonthlyInvestment / afterTaxMonthlyIncome) * 100 : (requiredMonthlyInvestment > 0 ? Infinity : 0);
            
            let feedbackMessage = '';
            if (requiredMonthlyInvestment <= 0) {
                feedbackMessage = '追加の積立は不要です。現在の資産と利回りだけで目標を達成できる見込みです。';
            } else if (afterTaxMonthlyIncome <= 0) {
                feedbackMessage = '目標達成にはまず収入を確保することが最優先です。収入を増やす方法を考えましょう！';
            } else if (requiredSavingsRate <= 25) {
                feedbackMessage = '素晴らしい！現実的な目標です。この調子で頑張りましょう！';
            } else if (requiredSavingsRate <= 40) {
                feedbackMessage = '良い目標です！少し意識すれば達成可能でしょう。';
            } else if (requiredSavingsRate <= 60) {
                feedbackMessage = '挑戦的な目標です！家計の見直しや収入アップも視野に入れましょう。';
            } else if (requiredSavingsRate <= 100) {
                feedbackMessage = 'かなり高い目標です！副業やパートナーとの協力も検討しましょう。';
            } else {
                feedbackMessage = '達成困難な目標です。収入を大幅に増やす必要があります。';
            }

            const yearsToGoal = Math.floor(durationYears);
            const monthsToGoal = Math.round((durationYears - yearsToGoal) * 12);

            const resultsForDisplay = {
                isAchievable: true,
                goalAge: targetGoalAge,
                goalAgeMonthsPart: 0,
                yearsToGoal: yearsToGoal,
                monthsToGoal: monthsToGoal,
                finalTotalAssets: finalState.finalTotalAssets,
                totalPrincipal: finalState.totalPrincipal,
                totalInterest: finalState.totalInterest,
            };

            const reverseResultsForDisplay = {
                requiredMonthlyInvestment: Number(requiredMonthlyInvestment.toFixed(1)),
                requiredSavingsRate: isFinite(requiredSavingsRate) ? Number(requiredSavingsRate.toFixed(1)) : Infinity,
                feedbackMessage,
                isAchievable: true,
                handsOff: handsOffResults,
            };

            return { results: resultsForDisplay, chartData, reverseResults: reverseResultsForDisplay };
        }

        const initialMonthlyIncome = Number(inputs.afterTaxMonthlyIncome) || 0;
        let effectiveMonthlyInvestment = 0;
        if (inputs.simulationMode === 'savingsRate') {
            const rate = Number(inputs.targetSavingsRate) || 0;
            effectiveMonthlyInvestment = (initialMonthlyIncome * rate) / 100;
        } else {
            effectiveMonthlyInvestment = Number(inputs.monthlyInvestment) || 0;
        }

        const forwardSim = runForwardSimulation(currentAge, currentAssets, effectiveMonthlyInvestment, annualYield, effectiveTargetAssets, inputs.lifeEvents, initialMonthlyIncome);
        return { ...forwardSim, reverseResults: null };
      }, [inputs]);
    };

    // --- from components/InputForm.tsx ---
    const ModelCaseSelector = ({ isOpen, onClose, onSelect, mode }) => {
        if (!isOpen) return null;

        const MODEL_CASES = {
          contribution: [
            { name: '堅実プラン', values: { monthlyInvestment: 3, annualYield: 3, targetAssets: 3000 }, description: 'リスクを抑え、コツコツと資産形成を目指すプランです。' },
            { name: '標準プラン', values: { monthlyInvestment: 5, annualYield: 5, targetAssets: 5000 }, description: '平均的なリターンを狙い、バランスの取れた資産形成を目指します。' },
            { name: '積極プラン', values: { monthlyInvestment: 10, annualYield: 7, targetAssets: 8000 }, description: 'リスクを取り、より大きなリターンを目指す上級者向けプランです。' },
          ],
          savingsRate: [
            { name: '節約家プラン', values: { targetSavingsRate: 15, annualYield: 3, targetAssets: 4000 }, description: '無理なく始められる貯蓄率で、着実に資産を増やします。' },
            { name: '標準プラン', values: { targetSavingsRate: 25, annualYield: 5, targetAssets: 6000 }, description: '収入の4分の1を投資に回し、効率的な資産拡大を目指します。' },
            { name: 'てらぞん激推しプラン', values: { targetSavingsRate: 60, annualYield: 5, targetAssets: 5000 }, description: '倹約家に転身。収入が上がっても常に貯蓄率60％を目指し、副業やパートナーとの協力によって最短最速で資産5000万円を目指します。' },
          ],
          reverse: [
            { name: 'サイドFIREプラン', values: { targetGoalAge: 55, goalSettingMode: 'fire', fireMonthlyLivingCost: 15, fireMonthlySideIncome: 5, fireWithdrawalRate: 4 }, description: '完全にリタイアせず、好きな仕事で少し働きながら生活するプランです。' },
            { name: '完全リタイアプラン', values: { targetGoalAge: 60, goalSettingMode: 'fire', fireMonthlyLivingCost: 20, fireMonthlySideIncome: 0, fireWithdrawalRate: 4 }, description: '60歳で仕事から完全に引退し、悠々自適な生活を目指します。' },
            { name: '億り人プラン', values: { targetGoalAge: 65, goalSettingMode: 'amount', targetAssets: 10000 }, description: '資産1億円という大きな目標を、長期的な視点で目指すプランです。' },
          ],
        };

        const VALUE_LABELS = {
          monthlyInvestment: { label: '毎月の積立額', unit: '万円' },
          annualYield: { label: '想定利回り', unit: '%' },
          targetAssets: { label: '目標資産額', unit: '万円' },
          targetSavingsRate: { label: '目標貯蓄率', unit: '%' },
          targetGoalAge: { label: '目標達成年齢', unit: '歳' },
          goalSettingMode: { label: '目標の種類', unit: '' },
          fireMonthlyLivingCost: { label: 'リタイア後の月間生活費', unit: '万円' },
          fireMonthlySideIncome: { label: 'リタイア後の月間労働収入', unit: '万円' },
          fireWithdrawalRate: { label: '資産の取り崩し率', unit: '%' },
        };

        const cases = MODEL_CASES[mode] || [];
        const modeTitle = {
            contribution: '「積立額から計算」モードのモデルケース',
            savingsRate: '「貯蓄率から計算」モードのモデルケース',
            reverse: '「目標から逆算」モードのモデルケース',
        };

        return (
            <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4 animate-fade-in-fast" onClick={onClose} aria-modal="true" role="dialog">
                <div className="bg-white rounded-2xl shadow-xl w-full max-w-4xl max-h-[90vh] overflow-y-auto" onClick={e => e.stopPropagation()}>
                    <div className="p-6 sticky top-0 bg-white border-b z-10">
                        <h3 className="text-xl font-bold text-slate-800">{modeTitle[mode]}</h3>
                        <p className="text-sm text-slate-500 mt-1">プランを選択すると、入力欄にサンプル数値が自動でセットされます。</p>
                        <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600 transition-colors" aria-label="閉じる">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" /></svg>
                        </button>
                    </div>
                    <div className="p-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {cases.map(plan => (
                            <div key={plan.name} className="bg-slate-50 border border-slate-200 rounded-lg p-5 flex flex-col hover:shadow-md hover:border-indigo-300 transition-all">
                                <h4 className="font-bold text-lg text-indigo-600 mb-2">{plan.name}</h4>
                                <p className="text-sm text-slate-600 flex-grow mb-4">{plan.description}</p>
                                <div className="mb-4 pt-3 border-t border-slate-200">
                                    <h5 className="text-xs font-bold text-slate-500 mb-2">設定される項目</h5>
                                    <ul className="text-sm space-y-1 text-slate-700">
                                        {Object.entries(plan.values).map(([key, value]) => {
                                            const config = VALUE_LABELS[key];
                                            if (!config) return null;

                                            let displayValue = value;
                                            let displayUnit = config.unit;
                                            
                                            if (key === 'goalSettingMode') {
                                                displayValue = value === 'fire' ? 'FIREプラン' : '金額で指定';
                                                displayUnit = '';
                                            }

                                            return (
                                                <li key={key} className="flex justify-between items-baseline">
                                                    <span className="text-xs">{config.label}</span>
                                                    <span className="font-semibold text-right">{displayValue}
                                                      <span className="text-xs ml-1">{displayUnit}</span>
                                                    </span>
                                                </li>
                                            );
                                        })}
                                    </ul>
                                </div>
                                <button 
                                    onClick={() => onSelect(plan.values)} 
                                    className="mt-auto w-full py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150"
                                >
                                    この設定を適用
                                </button>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        );
    };

    const InputField = ({ label, name, value, onChange, unit, tooltip, min = 0, max, step = 0.01, error }) => (
      <div>
        <label htmlFor={name} className="block text-sm font-medium text-slate-600 mb-1">
          {label}
          {tooltip && (
            <Tooltip text={tooltip}>
              <InfoIcon className="ml-1 text-slate-400" />
            </Tooltip>
          )}
        </label>
        <div className="relative">
          <input
            type="number" id={name} name={name} value={value} onChange={onChange}
            min={min} max={max} step={step} placeholder="入力してください"
            onWheel={(e) => e.currentTarget.blur()}
            onKeyDown={(e) => { if (['e', 'E', '+', '-'].includes(e.key)) e.preventDefault(); }}
            className={`w-full pl-3 pr-12 py-2 border rounded-lg shadow-sm focus:ring-2 transition bg-white text-slate-900 ${error ? 'border-red-500 focus:ring-red-500 focus:border-red-500' : 'border-slate-300 focus:ring-indigo-500 focus:border-indigo-500'}`}
            aria-invalid={!!error}
            aria-describedby={error ? `${name}-error` : undefined}
          />
          <span className="absolute inset-y-0 right-0 flex items-center pr-3 text-slate-500">{unit}</span>
        </div>
        {error && <p id={`${name}-error`} className="mt-1 text-xs text-red-600 animate-fade-in" role="alert">{error}</p>}
      </div>
    );
    const LifeEventCard = ({ event, onChange, onDelete, beforeIncome, beforeInvestment, beforeRate }) => {
        const { useMemo } = React;
        
        const effectiveIncome = useMemo(() => {
             // Use new income if it's a valid number (including 0), otherwise use the income before this event.
             return (event.newMonthlyIncome !== '' && !isNaN(Number(event.newMonthlyIncome)))
                ? Number(event.newMonthlyIncome) 
                : beforeIncome;
        }, [event.newMonthlyIncome, beforeIncome]);

        const calculatedRate = useMemo(() => {
            if (event.goalType === 'amount' && effectiveIncome > 0) {
                 return Number(((Number(event.goalValue) || 0) / effectiveIncome * 100).toFixed(1));
            }
            return null;
        }, [event.goalType, event.goalValue, effectiveIncome]);

        const calculatedAmount = useMemo(() => {
            if (event.goalType === 'rate') {
                return Number((effectiveIncome * (Number(event.goalValue) || 0) / 100).toFixed(1));
            }
            return null;
        }, [event.goalType, event.goalValue, effectiveIncome]);

        return (
            <details className="bg-slate-100 p-3 rounded-lg animate-fade-in group border border-slate-200" open>
                <summary className="flex justify-between items-center font-semibold text-slate-700 cursor-pointer">
                    <div className="flex items-center">
                        <input type="number" name="age" value={event.age} onChange={(e) => onChange(event.id, 'age', e.target.value)} onWheel={(e) => e.currentTarget.blur()} className="w-16 p-1 border border-slate-300 rounded-md text-sm text-center bg-white text-slate-900 font-bold" onClick={(e) => e.stopPropagation()} step="1" />
                        <span className="ml-2">歳からのライフイベント</span>
                    </div>
                    <button onClick={(e) => { e.preventDefault(); onDelete(event.id); }} className="text-red-500 hover:text-red-700 font-bold p-1 rounded-full">&times;</button>
                </summary>
                <div className="mt-4 space-y-4 border-t pt-4">
                    <div>
                        <label className="text-sm font-medium text-slate-600">手取り月収</label>
                        <div className="flex items-center flex-wrap gap-2 text-sm mt-1">
                            <span className="text-slate-500 whitespace-nowrap">変更前: {beforeIncome.toFixed(1)} 万円</span>
                            <span>→</span>
                            <div className="relative flex-grow min-w-[7rem]">
                                <input type="number" name="newMonthlyIncome" value={event.newMonthlyIncome} onChange={(e) => onChange(event.id, 'newMonthlyIncome', e.target.value)} onWheel={(e) => e.currentTarget.blur()} className="w-full py-1 pl-3 pr-10 border border-slate-300 rounded-md text-sm bg-white text-slate-900" placeholder="入力" min={0} step="0.1" />
                                 <span className="absolute inset-y-0 right-0 flex items-center pr-2 text-slate-500">万円</span>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label className="text-sm font-medium text-slate-600">積立目標</label>
                        <div className="flex items-center space-x-4 mt-1">
                             <label className="flex items-center cursor-pointer">
                                <input type="radio" name={`goalType-${event.id}`} value="amount" checked={event.goalType === 'amount'} onChange={() => onChange(event.id, 'goalType', 'amount')} className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-slate-300" />
                                <span className="ml-2 text-xs text-slate-700">積立額で指定</span>
                            </label>
                             <label className="flex items-center cursor-pointer">
                                <input type="radio" name={`goalType-${event.id}`} value="rate" checked={event.goalType === 'rate'} onChange={() => onChange(event.id, 'goalType', 'rate')} className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-slate-300" />
                                <span className="ml-2 text-xs text-slate-700">貯蓄率で指定</span>
                            </label>
                        </div>
                    </div>
                    {event.goalType === 'amount' ? (
                        <div>
                            <div className="flex items-center flex-wrap gap-2 text-sm">
                                <span className="text-slate-500 whitespace-nowrap">変更前: {beforeInvestment.toFixed(1)} 万円</span>
                                <span>→</span>
                                 <div className="relative flex-grow min-w-[7rem]">
                                    <input type="number" name="goalValue" value={event.goalValue} onChange={(e) => onChange(event.id, 'goalValue', e.target.value)} onWheel={(e) => e.currentTarget.blur()} className="w-full py-1 pl-3 pr-10 border border-slate-300 rounded-md text-sm bg-white text-slate-900" placeholder="入力" min={0} step="0.1" />
                                    <span className="absolute inset-y-0 right-0 flex items-center pr-2 text-slate-500">万円</span>
                                 </div>
                            </div>
                            {calculatedRate !== null && <p className="text-xs text-slate-500 mt-1">(自動計算された貯蓄率: {calculatedRate.toFixed(1)} %)</p>}
                        </div>
                    ) : (
                        <div>
                            <div className="flex items-center flex-wrap gap-2 text-sm">
                                 <span className="text-slate-500 whitespace-nowrap">変更前: {beforeRate.toFixed(1)} %</span>
                                 <span>→</span>
                                  <div className="relative flex-grow min-w-[7rem]">
                                    <input type="number" name="goalValue" value={event.goalValue} onChange={(e) => onChange(event.id, 'goalValue', e.target.value)} onWheel={(e) => e.currentTarget.blur()} className="w-full py-1 pl-3 pr-8 border border-slate-300 rounded-md text-sm bg-white text-slate-900" placeholder="入力" min={0} step="0.1" />
                                    <span className="absolute inset-y-0 right-0 flex items-center pr-2 text-slate-500">%</span>
                                  </div>
                            </div>
                            {calculatedAmount !== null && <p className="text-xs text-slate-500 mt-1">(自動計算された積立額: {calculatedAmount.toFixed(1)} 万円)</p>}
                        </div>
                    )}
                </div>
            </details>
        );
    };
    const ModeSwitcher = ({ mode, onModeChange }) => {
        const modes = [
            { key: 'contribution', label: '① 積立額から計算' },
            { key: 'savingsRate', label: '② 貯蓄率から計算' },
            { key: 'reverse', label: '③ 目標から逆算' },
        ];
        return (
            <div id="tutorial-step-1">
                <label className="block text-sm font-medium text-slate-600 mb-2">シミュレーションモードを選択</label>
                <div className="flex bg-slate-200 rounded-lg p-1 space-x-1">
                    {modes.map(m => (
                        <button key={m.key} onClick={() => onModeChange(m.key)} className={`w-1/3 py-2 px-1 text-xs md:text-sm font-semibold rounded-md transition-all duration-300 ${mode === m.key ? 'bg-white text-indigo-600 shadow' : 'bg-transparent text-slate-600 hover:bg-slate-300'}`}>
                            {m.label}
                        </button>
                    ))}
                </div>
            </div>
        );
    };
    const GoalSettingSwitcher = ({ mode, onModeChange }) => (
        <div className="flex items-center justify-center space-x-4">
            <label className="flex items-center cursor-pointer">
                <input type="radio" name="goal-setting" value="amount" checked={mode === 'amount'} onChange={() => onModeChange('amount')} className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-slate-300" />
                <span className="ml-2 text-sm text-slate-700">金額で指定</span>
            </label>
             <label className="flex items-center cursor-pointer">
                <input type="radio" name="goal-setting" value="fire" checked={mode === 'fire'} onChange={() => onModeChange('fire')} className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-slate-300" />
                <span className="ml-2 text-sm text-slate-700">FIREプランで指定</span>
            </label>
        </div>
    );
    const InputForm = ({ inputs, onInputChange, onSetInputs, onReset, onAddEvent, onDeleteEvent, onEventChange, onModeChange, onGoalSettingModeChange, errors }) => {
      const { useState, useMemo } = React;
      const [isModelCaseModalOpen, setModelCaseModalOpen] = useState(false);
      
      const handleSelectModelCase = (values) => {
        onSetInputs(prev => ({ ...prev, ...values }));
        setModelCaseModalOpen(false);
      };
      
      const calculatedInvestment = useMemo(() => {
        if (inputs.simulationMode !== 'savingsRate') return 0;
        const income = Number(inputs.afterTaxMonthlyIncome) || 0;
        const rate = Number(inputs.targetSavingsRate) || 0;
        return Number(((income * rate) / 100).toFixed(1));
      }, [inputs.simulationMode, inputs.afterTaxMonthlyIncome, inputs.targetSavingsRate]);
      
      const calculatedFireTargetAssets = useMemo(() => {
        if (inputs.simulationMode !== 'reverse' || inputs.goalSettingMode !== 'fire') return 0;
        const livingCost = Number(inputs.fireMonthlyLivingCost) || 0;
        const sideIncome = Number(inputs.fireMonthlySideIncome) || 0;
        const withdrawalRate = Number(inputs.fireWithdrawalRate) || 0;
        if (withdrawalRate <= 0) return 0;
        const requiredAnnualSpending = (livingCost - sideIncome) * 12;
        if (requiredAnnualSpending <= 0) return 0;
        const target = requiredAnnualSpending / (withdrawalRate / 100);
        return Math.round(target);
      }, [inputs.simulationMode, inputs.goalSettingMode, inputs.fireMonthlyLivingCost, inputs.fireMonthlySideIncome, inputs.fireWithdrawalRate]);

      const eventPrecursors = useMemo(() => {
            const precursors = new Map();
            const sortedEvents = [...inputs.lifeEvents].sort((a, b) => (Number(a.age) || Infinity) - (Number(b.age) || Infinity));
            let currentIncome = Number(inputs.afterTaxMonthlyIncome) || 0;
            let currentInvestment = 0;
            if (inputs.simulationMode === 'contribution') {
                currentInvestment = Number(inputs.monthlyInvestment) || 0;
            } else if (inputs.simulationMode === 'savingsRate') {
                const rate = Number(inputs.targetSavingsRate) || 0;
                currentInvestment = Number(((currentIncome * rate) / 100).toFixed(1));
            } else {
                 currentInvestment = 0;
            }
            for (const event of sortedEvents) {
                const currentRate = currentIncome > 0 ? (currentInvestment / currentIncome) * 100 : 0;
                precursors.set(event.id, { 
                  income: Number(currentIncome.toFixed(1)),
                  investment: Number(currentInvestment.toFixed(1)), 
                  rate: Number(currentRate.toFixed(1))
                });
                const eventIncome = Number(event.newMonthlyIncome);
                if (event.newMonthlyIncome !== '' && !isNaN(eventIncome)) {
                     currentIncome = eventIncome;
                }
                
                if (event.goalType === 'rate') {
                    currentInvestment = Number(((currentIncome * (Number(event.goalValue) || 0)) / 100).toFixed(1));
                } else {
                    currentInvestment = Number(event.goalValue) || 0;
                }
            }
            return precursors;
        }, [inputs.lifeEvents, inputs.afterTaxMonthlyIncome, inputs.monthlyInvestment, inputs.targetSavingsRate, inputs.simulationMode]);
      
      const isReverseMode = inputs.simulationMode === 'reverse';
      const ModelCaseButton = () => (
        <div className="mt-6">
          <Tooltip 
            text="プランを選択すると、このモードに関連する項目が自動で入力されます。現在の入力値は上書きされますのでご注意ください。" 
            className="w-full"
          >
            <button
              type="button"
              onClick={() => setModelCaseModalOpen(true)}
              className="w-full py-2 px-4 bg-teal-500 text-white font-semibold rounded-lg hover:bg-teal-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 transition duration-150 flex items-center justify-center"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" /></svg>
              モデルケースから設定する
            </button>
          </Tooltip>
        </div>
      );
      
      return (
        <div className="bg-white p-6 rounded-2xl shadow-lg">
          <ModelCaseSelector
            isOpen={isModelCaseModalOpen}
            onClose={() => setModelCaseModalOpen(false)}
            onSelect={handleSelectModelCase}
            mode={inputs.simulationMode}
          />
          <h2 className="text-xl font-bold text-slate-800 mb-6 border-b pb-3">シミュレーション条件</h2>
          <div className="space-y-5">
            <ModeSwitcher mode={inputs.simulationMode} onModeChange={onModeChange} />
            <div id="tutorial-step-2" className="space-y-5 pt-4 border-t">
              <InputField label="現在の年齢" name="currentAge" value={inputs.currentAge} onChange={onInputChange} unit="歳" step={1} error={errors.currentAge} />
              <InputField label="現在の資産" name="currentAssets" value={inputs.currentAssets} onChange={onInputChange} unit="万円" step={1} error={errors.currentAssets} />
              <InputField label="想定利回り" name="annualYield" value={inputs.annualYield} onChange={onInputChange} unit="%" tooltip="1年間の投資で得られる利益の割合です。このシミュレーターでは、入力された年利が1年後のリターンと一致するように、内部で月単位の複利計算を行っています。例えば年利5%と入力すると、1年後には資産がちょうど5%増加します。S&P500等の平均リターンは年5～7%が目安です。" step={1} error={errors.annualYield} />
              {inputs.simulationMode === 'contribution' && (<>
                  <div>
                     <InputField label="毎月の積立額" name="monthlyInvestment" value={inputs.monthlyInvestment} onChange={onInputChange} unit="万円" max={1000} step={0.1} error={errors.monthlyInvestment} />
                      <input type="range" name="monthlyInvestment" value={inputs.monthlyInvestment} onChange={onInputChange} min="0" max="100" step="0.1" className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer mt-2 accent-indigo-600" />
                  </div>
                  <InputField label="目標資産額" name="targetAssets" value={inputs.targetAssets} onChange={onInputChange} unit="万円" step={1} error={errors.targetAssets} />
                  <ModelCaseButton />
                </>)}
              {inputs.simulationMode === 'savingsRate' && (<>
                  <div className="space-y-5 p-4 bg-slate-50 rounded-lg">
                      <InputField label="手取り月収" name="afterTaxMonthlyIncome" value={inputs.afterTaxMonthlyIncome} onChange={onInputChange} unit="万円" step={0.1} error={errors.afterTaxMonthlyIncome} />
                      <InputField label="目標貯蓄率" name="targetSavingsRate" value={inputs.targetSavingsRate} onChange={onInputChange} unit="%" max={100} step={0.1} error={errors.targetSavingsRate} />
                      <div className="text-center border-t pt-3">
                          <p className="text-sm text-slate-600">毎月の積立額（自動計算）</p>
                          <p className="text-2xl font-bold text-indigo-600">{calculatedInvestment.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} 万円</p>
                      </div>
                  </div>
                  <InputField label="目標資産額" name="targetAssets" value={inputs.targetAssets} onChange={onInputChange} unit="万円" step={1} error={errors.targetAssets} />
                  <ModelCaseButton />
                </>)}
              {inputs.simulationMode === 'reverse' && (<div className="space-y-5">
                    <InputField label="手取り月収" name="afterTaxMonthlyIncome" value={inputs.afterTaxMonthlyIncome} onChange={onInputChange} unit="万円" step={0.1} error={errors.afterTaxMonthlyIncome} />
                    <InputField label="目標達成年齢" name="targetGoalAge" value={inputs.targetGoalAge} onChange={onInputChange} unit="歳" step={1} error={errors.targetGoalAge} />
                    <div className="border-t pt-4 space-y-4">
                      <label className="block text-sm font-medium text-slate-600 text-center">▼ どんなゴールを目指しますか？</label>
                      <GoalSettingSwitcher mode={inputs.goalSettingMode} onModeChange={onGoalSettingModeChange} />
                      {inputs.goalSettingMode === 'amount' && (<InputField label="目標資産額" name="targetAssets" value={inputs.targetAssets} onChange={onInputChange} unit="万円" step={1} error={errors.targetAssets} />)}
                      {inputs.goalSettingMode === 'fire' && (<div className="space-y-5 p-4 bg-slate-50 rounded-lg animate-fade-in">
                            <InputField label="リタイア後の月間生活費" name="fireMonthlyLivingCost" value={inputs.fireMonthlyLivingCost} onChange={onInputChange} unit="万円" tooltip="FIRE後に毎月必要になるであろう生活費を入力してください。" step={0.1} error={errors.fireMonthlyLivingCost} />
                            <InputField label="リタイア後の月間労働収入" name="fireMonthlySideIncome" value={inputs.fireMonthlySideIncome} onChange={onInputChange} unit="万円" tooltip="サイドFIREなどで見込む、リタイア後の労働収入です。なければ0を入力してください。" step={0.1} error={errors.fireMonthlySideIncome} />
                            <InputField label="資産の取り崩し率" name="fireWithdrawalRate" value={inputs.fireWithdrawalRate} onChange={onInputChange} unit="%" tooltip="資産を毎年何%ずつ使っていくか。一般的に4%が目安とされます。" step={0.1} error={errors.fireWithdrawalRate} />
                            <div className="text-center border-t pt-3">
                                <p className="text-sm text-slate-600">そのために必要な目標資産額（自動計算）</p>
                                <p className="text-2xl font-bold text-indigo-600">{calculatedFireTargetAssets.toLocaleString()} 万円</p>
                            </div>
                          </div>)}
                    </div>
                    <ModelCaseButton />
                </div>)}
            </div>
          </div>
          <div id="tutorial-step-5" className={`mt-8 transition-opacity duration-300 ${isReverseMode ? 'opacity-50 pointer-events-none' : ''}`}>
            <h3 className="text-lg font-bold text-slate-700 mb-4 border-b pb-2">ライフイベント</h3>
            {isReverseMode && (<div className="text-xs text-amber-700 bg-amber-100 p-2 rounded-md mb-3">(注)逆算モードではライフイベントは設定できません</div>)}
            <div className="space-y-3 mb-4">{inputs.lifeEvents.map(event => {
                    const precursor = eventPrecursors.get(event.id) || { income: 0, investment: 0, rate: 0 };
                    return (<LifeEventCard key={event.id} event={event} onChange={onEventChange} onDelete={onDeleteEvent} beforeIncome={precursor.income} beforeInvestment={precursor.investment} beforeRate={precursor.rate} />);
              })}</div>
            <button onClick={onAddEvent} className="w-full py-2 px-4 bg-sky-500 text-white font-semibold rounded-lg hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 transition duration-150 disabled:bg-sky-300 disabled:cursor-not-allowed" disabled={isReverseMode}>+ イベントを追加</button>
          </div>
          <div className="pt-8"><button onClick={onReset} className="w-full py-2 px-4 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500 transition duration-150">入力値をリセット</button></div>
        </div>
      );
    };

    // --- from components/ResultsDisplay.tsx ---
    const ResultCard = ({ title, children, className }) => (
        <div className={`bg-white p-4 rounded-xl shadow-md flex flex-col items-center justify-center text-center ${className}`}>
            <h3 className="text-sm font-semibold text-slate-500 mb-1">{title}</h3>
            <div className="text-2xl lg:text-3xl font-bold text-slate-800">{children}</div>
        </div>
    );
    const HandsOffInfoCard = ({ results }) => (
        <div className="sm:col-span-2 bg-emerald-50 border-l-4 border-emerald-500 text-emerald-800 p-4 rounded-xl shadow-md animate-fade-in">
            <h3 className="font-bold text-lg mb-2">【朗報！】ほったらかしでも達成可能です</h3>
            <p>追加の積立をしなくても、あなたの資産は <strong className="text-2xl font-bold">{results.goalAge}歳 {results.goalAgeMonthsPart}ヶ月</strong> で目標達成できる見込みです！</p>
        </div>
    );
    const ReverseResultCard = ({ reverseResults }) => {
        if (!reverseResults.isAchievable) {
            return (<div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-xl shadow-md sm:col-span-2"><p className="font-bold">目標達成は困難です</p><p>{reverseResults.feedbackMessage}</p></div>)
        }
        
        const rateColor = reverseResults.requiredSavingsRate > 50 ? 'text-red-500' : reverseResults.requiredSavingsRate > 35 ? 'text-amber-500' : 'text-emerald-500';

        return (
            <div className="bg-indigo-50 border-l-4 border-indigo-500 text-indigo-800 p-4 rounded-xl shadow-md sm:col-span-2">
                <h3 className="font-bold text-lg mb-2">目標達成のための試算結果</h3>
                <p>あなたの目標を達成するには、毎月 <strong className={`text-2xl font-bold ${rateColor}`}>{reverseResults.requiredMonthlyInvestment.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} 万円</strong> の積立が必要です。</p>
                {isFinite(reverseResults.requiredSavingsRate) ? (
                    <p className="mt-1">これは手取り月収に対し、<strong className={`text-2xl font-bold ${rateColor}`}>{reverseResults.requiredSavingsRate.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}%</strong> の貯蓄率に相当します。</p>
                ) : (
                    <p className="mt-1">現在の収入が0円のため、貯蓄率は計算できません。</p>
                )}
                <p className="mt-3 text-sm bg-indigo-100 p-2 rounded-md">{reverseResults.feedbackMessage}</p>
            </div>
        );
    };
    const ResultsDisplay = ({ results, reverseResults, mode, inputs, isValid }) => {
      const formatYen = (amount) => new Intl.NumberFormat('ja-JP').format(amount) + '万円';

      if (!isValid) {
          return (<div id="tutorial-step-3" className="flex flex-col items-center justify-center min-h-[10rem] bg-red-50 p-6 rounded-2xl shadow-inner text-red-700 text-center"><p className="font-bold text-lg">入力エラー</p><p className="mt-2">シミュレーション条件の入力にエラーがあります。メッセージに従って値を修正してください。</p></div>);
      }
      
      if (!results && !reverseResults) {
        return (<div id="tutorial-step-3" className="flex items-center justify-center min-h-[10rem] bg-slate-100 p-6 rounded-2xl shadow-inner text-slate-500">条件を入力してシミュレーションを開始してください。</div>);
      }
      
      if (results && !results.isAchievable) {
        return (<div id="tutorial-step-3" className="flex items-center justify-center min-h-[10rem] bg-amber-50 p-6 rounded-2xl shadow-inner text-amber-700">現在の設定では100年以内に目標を達成できません。積立額を増やすか、目標を調整してください。</div>);
      }

      if (!results) { // This now only catches the unachievable case in reverse mode.
           return (
              <div id="tutorial-step-3" className="bg-slate-100 p-6 rounded-2xl shadow-inner space-y-4">
                  <h2 className="text-xl font-bold text-slate-800 mb-2 border-b pb-3">シミュレーション結果</h2>
                   {mode === 'reverse' && reverseResults && <ReverseResultCard reverseResults={reverseResults} />}
              </div>
            )
      }

      const showHandsOffCard = mode === 'reverse' && reverseResults?.handsOff && reverseResults.handsOff.finalAge <= (Number(inputs.targetGoalAge) || 0);

      return (
        <div id="tutorial-step-3" className="bg-slate-100 p-6 rounded-2xl shadow-inner">
          <h2 className="text-xl font-bold text-slate-800 mb-6 border-b pb-3">シミュレーション結果</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              {showHandsOffCard && <HandsOffInfoCard results={reverseResults.handsOff} />}
              {mode === 'reverse' && reverseResults && <ReverseResultCard reverseResults={reverseResults} />}
              
              <div className="bg-indigo-600 text-white p-4 rounded-xl shadow-lg flex flex-col items-center justify-center text-center sm:col-span-2">
                <h3 className="text-base font-semibold text-indigo-200 mb-1">目標達成年齢</h3>
                <p className="text-4xl lg:text-5xl font-extrabold">{results.goalAge}歳 <span className="text-2xl lg:text-3xl font-semibold">{results.goalAgeMonthsPart}ヶ月</span></p>
              </div>
              
              <ResultCard title="達成まであと">{results.yearsToGoal}年 {results.monthsToGoal}ヶ月</ResultCard>
              <ResultCard title="最終資産額">{formatYen(results.finalTotalAssets)}</ResultCard>
              
               <div className="bg-white p-4 rounded-xl shadow-md flex flex-col items-center justify-center text-center sm:col-span-2">
                    <div className="w-full">
                        <div className="flex justify-between text-sm text-slate-600 mb-1"><span>積立元本</span><span>運用利益</span></div>
                        <div className="w-full bg-slate-200 rounded-full h-4 overflow-hidden flex">
                            <div className="bg-sky-500" style={{ width: `${(results.totalPrincipal / results.finalTotalAssets) * 100}%` }}></div>
                            <div className="bg-emerald-500" style={{ width: `${(results.totalInterest / results.finalTotalAssets) * 100}%` }}></div>
                        </div>
                         <div className="flex justify-between text-sm font-bold mt-1">
                            <span className="text-sky-600">{formatYen(results.totalPrincipal)}</span>
                            <span className="text-emerald-600">{formatYen(results.totalInterest)}</span>
                        </div>
                    </div>
               </div>
          </div>
        </div>
      );
    };

    // --- from components/AssetChart.tsx ---
    const EventMarker = (props) => {
      const { cx, cy, payload } = props;
      if (payload.isEvent) return (<svg x={cx - 10} y={cy - 10} width="20" height="20" fill="#f59e0b" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" /></svg>);
      return null;
    };
    const AssetChart = ({ data }) => {
      if (!data || data.length <= 1) return (<div id="tutorial-step-4" className="flex items-center justify-center h-[400px] bg-white p-6 rounded-2xl shadow-lg text-slate-500">グラフを表示するには、有効なシミュレーション結果が必要です。</div>);
      const formatYen = (value) => `${value.toLocaleString()} 万円`;
      const formatAge = (value) => `${Math.floor(value)}歳`;
      const maxAssets = data.length > 0 ? Math.max(...data.map(d => d.totalAssets), 0) : 0;
      let yAxisTicks = [0], topDomain = 1000;
      if (maxAssets > 0) {
        const interval = Math.ceil((maxAssets / 5) / 1000) * 1000;
        const safeInterval = Math.max(interval, 1000); 
        topDomain = Math.ceil(maxAssets / safeInterval) * safeInterval;
        yAxisTicks = [];
        for (let i = 0; i <= topDomain; i += safeInterval) yAxisTicks.push(i);
      }
      return (
        <div id="tutorial-step-4" className="bg-white p-4 md:p-6 rounded-2xl shadow-lg h-[400px]">
          <h3 className="text-xl font-bold text-slate-800 mb-4">資産推移グラフ</h3>
          <ResponsiveContainer width="100%" height="90%">
            <LineChart data={data} margin={{ top: 5, right: 20, left: 20, bottom: 5 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#e0e0e0" />
              <XAxis dataKey="age" tickFormatter={formatAge} tick={{ fill: '#64748b' }} minTickGap={20} />
              <YAxis tickFormatter={formatYen} tick={{ fill: '#64748b' }} width={80} domain={[0, topDomain]} ticks={yAxisTicks} allowDataOverflow={true} />
              <RechartsTooltip formatter={(value, name) => [formatYen(value), name]} labelFormatter={(label) => formatAge(label)} contentStyle={{ backgroundColor: 'rgba(255, 255, 255, 0.8)', backdropFilter: 'blur(4px)', border: '1px solid #e2e8f0', borderRadius: '0.75rem' }} />
              <Legend verticalAlign="top" height={36} />
              <Line type="monotone" dataKey="principal" stroke="#0ea5e9" strokeWidth={2} dot={false} name="積立元本" />
              <Line type="monotone" dataKey="totalAssets" stroke="#10b981" strokeWidth={3} dot={<EventMarker />} activeDot={{ r: 6 }} name="資産総額" />
            </LineChart>
          </ResponsiveContainer>
        </div>
      );
    };

    // --- from components/ShareModule.tsx ---
    const ShareModule = ({ results, chartData }) => {
        const { useState, useCallback } = React;
        const [isGenerating, setIsGenerating] = useState(false);
        const [imageDataUrl, setImageDataUrl] = useState(null); // 画像データURLを保持するState

        const getTimestamp = () => new Date().toISOString().replace(/[-:.]/g, "").replace("T", "_").slice(0,15);
        
        const handleDownloadImage = useCallback(async () => {
            const chartElement = document.getElementById('tutorial-step-4');
            if (chartElement && !isGenerating) {
                setIsGenerating(true);
                try {
                    const canvas = await html2canvas(chartElement, { backgroundColor: '#ffffff', scale: 2 });
                    const isMobile = window.innerWidth < 768; // モバイル判定

                    if (isMobile) {
                        // モバイルの場合はモーダルで画像を表示
                        setImageDataUrl(canvas.toDataURL('image/png'));
                    } else {
                        // PCの場合は直接ダウンロード
                        const link = document.createElement('a');
                        link.href = canvas.toDataURL('image/png');
                        link.download = 'asset-simulation-chart.png';
                        link.click();
                    }
                } catch (error) { 
                    console.error('Error generating image:', error); 
                    alert('画像の生成に失敗しました。'); 
                }
                finally { setIsGenerating(false); }
            }
        }, [isGenerating]);

        const handleDownloadCsv = useCallback(() => {
            if (!chartData || chartData.length <= 1) return alert('CSVエクスポート用のデータがありません。');
            const headers = ['年齢(歳)', '年初資産額(万円)', '年間積立額(万円)', '年間運用益(万円)', '年末資産額(万円)'];
            const rows = chartData.slice(1).map((item, index) => {
                const prevItem = chartData[index];
                const age = Math.floor(prevItem.age);
                const startOfYearAssets = prevItem.totalAssets;
                const endOfYearAssets = item.totalAssets;
                const annualContribution = item.principal - prevItem.principal;
                const annualInterest = endOfYearAssets - startOfYearAssets - annualContribution;
                return [age, startOfYearAssets, annualContribution, annualInterest, endOfYearAssets].join(',');
            });
            const csvContent = [headers.join(','), ...rows].join('\n');
            const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `asset_simulation_${getTimestamp()}.csv`;
            link.click();
            URL.revokeObjectURL(link.href);
        }, [chartData]);

        if (!results || !results.isAchievable) return null;

        const closeImageModal = () => setImageDataUrl(null);

        return (
            <>
                <div className="flex flex-col sm:flex-row justify-center items-center gap-4">
                    <button onClick={handleDownloadImage} disabled={isGenerating} className="w-full sm:w-auto flex items-center justify-center py-2 px-6 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700 transition duration-150 disabled:bg-slate-400"><svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>{isGenerating ? '生成中...' : 'グラフを画像で保存'}</button>
                    <button onClick={handleDownloadCsv} disabled={!chartData || chartData.length <= 1} className="w-full sm:w-auto flex items-center justify-center py-2 px-6 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition duration-150 disabled:bg-sky-300"><svg className="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>詳細データをダウンロード</button>
                </div>
                
                {/* 画像表示用モーダル */}
                {imageDataUrl && (
                    <div 
                        className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[9999] p-4 animate-fade-in-fast" 
                        onClick={closeImageModal} 
                        aria-modal="true" 
                        role="dialog"
                    >
                        <div 
                            className="bg-white rounded-2xl shadow-xl w-full max-w-lg p-4 sm:p-6 relative flex flex-col" 
                            onClick={e => e.stopPropagation()}
                        >
                            <h3 className="text-lg font-bold text-center text-slate-800 mb-2">生成された画像</h3>
                            <p className="text-center text-sm text-slate-600 mb-4">
                                画像を長押し（PCでは右クリック）して保存してください。
                            </p>
                            <div className="bg-slate-100 p-2 rounded-lg border">
                                <img src={imageDataUrl} alt="資産推移グラフ" className="w-full h-auto rounded-md" />
                            </div>
                            <button 
                                onClick={closeImageModal} 
                                className="mt-4 w-full py-2 px-4 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700 transition"
                                aria-label="閉じる"
                            >
                                閉じる
                            </button>
                        </div>
                    </div>
                )}
            </>
        );
    };
    

    // --- from App.tsx ---
    const INITIAL_STATE = {
      simulationMode: 'contribution',
      currentAge: 25, currentAssets: 100, monthlyInvestment: 5,
      afterTaxMonthlyIncome: 25, targetSavingsRate: 20, annualYield: 5,
      targetAssets: 5000, targetGoalAge: 45, lifeEvents: [],
      goalSettingMode: 'amount', fireMonthlyLivingCost: 15,
      fireMonthlySideIncome: 5, fireWithdrawalRate: 4,
    };
    const EMPTY_STATE = {
      simulationMode: 'contribution',
      currentAge: '',
      currentAssets: '',
      monthlyInvestment: '',
      afterTaxMonthlyIncome: '',
      targetSavingsRate: '',
      annualYield: '',
      targetAssets: '',
      targetGoalAge: '',
      lifeEvents: [],
      goalSettingMode: 'amount',
      fireMonthlyLivingCost: '',
      fireMonthlySideIncome: '',
      fireWithdrawalRate: '',
    };
    const STORAGE_KEY = 'futureSelfSimulatorPro_v5';
    const TUTORIAL_SEEN_KEY = 'futureSelfSimulatorPro_tutorial_v1';
    const Header = () => (<header className="bg-white shadow-md"><div className="container mx-auto px-4 py-4"><h1 className="text-xl md:text-2xl font-bold text-slate-800">【てらぞん】資産シミュレーター Pro</h1></div></header>);
    const Footer = ({ onRestartTutorial }) => (<footer className="bg-slate-800 text-slate-300 py-6 mt-12"><div className="container mx-auto px-4 text-center text-sm"><p>&copy; {new Date().getFullYear()} てらぞん</p><p className="mt-2">本シミュレーションは特定の金融商品を推奨するものではありません。投資は自己責任でお願いします。</p><div className="mt-4 flex justify-center items-center gap-x-4"><a href="https://www.youtube.com/@terazon-2025" target="_blank" rel="noopener noreferrer" className="inline-block text-indigo-400 hover:text-indigo-300 transition">YouTubeチャンネルはこちら</a><button onClick={onRestartTutorial} className="text-xs text-slate-400 hover:text-white transition">使い方ガイドを再表示</button></div></div></footer>);

    const App = () => {
      const { useState, useCallback, useEffect } = React;
      const [inputs, setInputs] = useState(() => {
        try {
          const savedState = localStorage.getItem(STORAGE_KEY);
          if (savedState) {
            const parsed = JSON.parse(savedState);
            const finalState = { ...INITIAL_STATE, ...parsed };
            finalState.lifeEvents = Array.isArray(finalState.lifeEvents) ? finalState.lifeEvents : [];
            return finalState;
          }
        } catch (error) { console.error("Failed to parse state", error); }
        return INITIAL_STATE;
      });
      const [errors, setErrors] = useState({});
      const [showTutorial, setShowTutorial] = useState(false);

      useEffect(() => {
        const newErrors = validateInputs(inputs);
        setErrors(newErrors);
      }, [inputs]);
      
      const isValid = Object.keys(errors).length === 0;
      const { results, chartData, reverseResults } = useSimulation(isValid ? inputs : null);

      useEffect(() => {
        const tutorialSeen = localStorage.getItem(TUTORIAL_SEEN_KEY);
        if (!tutorialSeen) {
            setShowTutorial(true);
        }
      }, []);

      useEffect(() => {
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(inputs)); }
        catch (error) { console.error("Failed to save state", error); }
      }, [inputs]);
      
      const handleCloseTutorial = useCallback((dontShowAgain) => {
        if (dontShowAgain) {
            localStorage.setItem(TUTORIAL_SEEN_KEY, 'true');
        }
        setShowTutorial(false);
      }, []);
      
      const handleRestartTutorial = useCallback(() => setShowTutorial(true), []);

      const handleInputChange = useCallback((e) => {
        const { name, value } = e.target;
        
        // Prevent invalid characters while allowing empty string and partial numbers like "25."
        if (value !== '' && !/^-?\d*\.?\d*$/.test(value)) {
            return;
        }

        setInputs(prev => ({ ...prev, [name]: value }));
      }, []);

      const handleModeChange = useCallback((newMode) => {
        setInputs(prev => {
            if (newMode === prev.simulationMode) {
                return prev;
            }

            const newInputs = { ...prev, simulationMode: newMode };

            // When switching FROM reverse FIRE mode, transfer the calculated target assets
            // to the standard target assets field. This is a helpful UX feature.
            if (prev.simulationMode === 'reverse' && prev.goalSettingMode === 'fire') {
                if (newMode === 'contribution' || newMode === 'savingsRate') {
                    const livingCost = Number(prev.fireMonthlyLivingCost) || 0;
                    const sideIncome = Number(prev.fireMonthlySideIncome) || 0;
                    const withdrawalRate = Number(prev.fireWithdrawalRate) || 0;
                    
                    if (withdrawalRate > 0) {
                        const requiredAnnualSpending = (livingCost - sideIncome) * 12;
                        if (requiredAnnualSpending > 0) {
                            const target = requiredAnnualSpending / (withdrawalRate / 100);
                            newInputs.targetAssets = Math.round(target);
                        } else {
                            newInputs.targetAssets = Number(prev.currentAssets) || 0;
                        }
                    }
                }
            }
            
            return newInputs;
        });
      }, []);

     const handleGoalSettingModeChange = useCallback((mode) => setInputs(prev => ({ ...prev, goalSettingMode: mode })), []);
     const handleReset = useCallback(() => { localStorage.removeItem(STORAGE_KEY); setInputs(EMPTY_STATE); }, []);
     const handleAddEvent = useCallback(() => {
        setInputs(prev => {
            const sortedEvents = [...prev.lifeEvents].sort((a, b) => (Number(a.age) || Infinity) - (Number(b.age) || Infinity));
            const lastEvent = sortedEvents.length > 0 ? sortedEvents[sortedEvents.length - 1] : null;
            let lastIncome, lastInvestment;
            if (lastEvent) {
                lastIncome = (lastEvent.newMonthlyIncome !== '' && !isNaN(Number(lastEvent.newMonthlyIncome))) ? Number(lastEvent.newMonthlyIncome) : Number(prev.afterTaxMonthlyIncome);
                lastInvestment = lastEvent.goalType === 'rate' ? (lastIncome * (Number(lastEvent.goalValue) || 0)) / 100 : Number(lastEvent.goalValue) || 0;
            } else {
                lastIncome = Number(prev.afterTaxMonthlyIncome);
                lastInvestment = prev.simulationMode === 'contribution' ? Number(prev.monthlyInvestment) : (lastIncome * (Number(prev.targetSavingsRate) || 0)) / 100;
            }
            const newEvent = { id: Date.now().toString(), age: (lastEvent ? Number(lastEvent.age) : Number(prev.currentAge)) + 5, newMonthlyIncome: Number(lastIncome.toFixed(1)), goalType: 'amount', goalValue: Number(lastInvestment.toFixed(1)) };
            return { ...prev, lifeEvents: [...prev.lifeEvents, newEvent] };
        });
      }, []);
      const handleDeleteEvent = useCallback((id) => setInputs(prev => ({ ...prev, lifeEvents: prev.lifeEvents.filter(event => event.id !== id) })), []);
      const handleEventChange = useCallback((id, field, value) => {
        setInputs(prev => {
           // For fields that should be numeric, validate the input string.
           // This prevents invalid characters while allowing partial numbers like "25."
           // 'goalType' is a string ('amount'/'rate') and should bypass this check.
           if (field !== 'goalType' && value !== '' && !/^-?\d*\.?\d*$/.test(value)) {
             return prev;
           }
           const finalValue = value;

           const newEvents = prev.lifeEvents.map(event => event.id === id ? { ...event, [field]: finalValue } : event);
           const sortedEvents = [...newEvents].sort((a, b) => (Number(a.age) || Infinity) - (Number(b.age) || Infinity));
           let precedingIncome = Number(prev.afterTaxMonthlyIncome);
           
           for(const ev of sortedEvents) {
               if (ev.id === id) break;
               if(Number(ev.newMonthlyIncome) > 0) precedingIncome = Number(ev.newMonthlyIncome);
           }
           
           const updatedEvents = newEvents.map(event => {
                if (event.id !== id) return event;
                
                const updatedEvent = { ...event };
                if(field === 'goalType') {
                    const incomeForConversion = Number(updatedEvent.newMonthlyIncome) > 0 ? Number(updatedEvent.newMonthlyIncome) : precedingIncome;
                    const currentGoalValue = Number(updatedEvent.goalValue) || 0;
                    if(value === 'rate' && incomeForConversion > 0) {
                        updatedEvent.goalValue = Number(((currentGoalValue / incomeForConversion) * 100).toFixed(1));
                    } else if (value === 'amount') {
                        updatedEvent.goalValue = Number(((incomeForConversion * currentGoalValue) / 100).toFixed(1));
                    }
                }
                return updatedEvent;
            });

            return { ...prev, lifeEvents: updatedEvents };
        });
      }, []);

      return (
        <div className="min-h-screen flex flex-col">
          <Tutorial isOpen={showTutorial} onClose={handleCloseTutorial} />
          <Header />
          <main className="flex-grow container mx-auto p-4 md:p-8">
            <div className="grid grid-cols-1 lg:grid-cols-5 gap-8">
              <div className="lg:col-span-2">
                <InputForm inputs={inputs} errors={errors} onInputChange={handleInputChange} onSetInputs={setInputs} onReset={handleReset} onAddEvent={handleAddEvent} onDeleteEvent={handleDeleteEvent} onEventChange={handleEventChange} onModeChange={handleModeChange} onGoalSettingModeChange={handleGoalSettingModeChange} />
              </div>
              <div className="lg:col-span-3 space-y-8">
                <ResultsDisplay results={results} reverseResults={reverseResults} mode={inputs.simulationMode} inputs={inputs} isValid={isValid} />
                <AssetChart data={isValid ? chartData : []} />
                <ShareModule results={isValid ? results : null} chartData={isValid ? chartData : []} />
              </div>
            </div>
          </main>
          <Footer onRestartTutorial={handleRestartTutorial} />
        </div>
      );
    };

    // ====================================================================================
    //  Final Render Call
    // ====================================================================================
    
    const rootElement = document.getElementById('root');
    if (!rootElement) {
      throw new Error("Could not find root element to mount to");
    }
    const root = ReactDOM.createRoot(rootElement);
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
